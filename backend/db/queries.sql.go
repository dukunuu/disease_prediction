// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDisease = `-- name: CreateDisease :one

INSERT INTO disease (
    disease_name, disease_code, disease_description, disease_treatment
) VALUES (
    $1, $2, $3, $4 -- $4 should be valid JSON(B) text or compatible type
)
RETURNING disease_id, disease_name, disease_code, disease_description, disease_treatment, created_at, updated_at
`

type CreateDiseaseParams struct {
	DiseaseName        string
	DiseaseCode        string
	DiseaseDescription pgtype.Text
	DiseaseTreatment   []byte
}

// === Disease Queries ===
func (q *Queries) CreateDisease(ctx context.Context, arg CreateDiseaseParams) (Disease, error) {
	row := q.db.QueryRow(ctx, createDisease,
		arg.DiseaseName,
		arg.DiseaseCode,
		arg.DiseaseDescription,
		arg.DiseaseTreatment,
	)
	var i Disease
	err := row.Scan(
		&i.DiseaseID,
		&i.DiseaseName,
		&i.DiseaseCode,
		&i.DiseaseDescription,
		&i.DiseaseTreatment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPatient = `-- name: CreatePatient :one


INSERT INTO patient (
    firstname, lastname, register, age, gender, birthdate, address, phonenumber, email
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING patient_id, firstname, lastname, register, age, gender, birthdate, address, phonenumber, email
`

type CreatePatientParams struct {
	Firstname   string
	Lastname    string
	Register    string
	Age         int32
	Gender      string
	Birthdate   pgtype.Date
	Address     pgtype.Text
	Phonenumber string
	Email       string
}

// queries.sql -- Updated for Refined PostgreSQL Schema with sqlc
// === Patient Queries ===
func (q *Queries) CreatePatient(ctx context.Context, arg CreatePatientParams) (Patient, error) {
	row := q.db.QueryRow(ctx, createPatient,
		arg.Firstname,
		arg.Lastname,
		arg.Register,
		arg.Age,
		arg.Gender,
		arg.Birthdate,
		arg.Address,
		arg.Phonenumber,
		arg.Email,
	)
	var i Patient
	err := row.Scan(
		&i.PatientID,
		&i.Firstname,
		&i.Lastname,
		&i.Register,
		&i.Age,
		&i.Gender,
		&i.Birthdate,
		&i.Address,
		&i.Phonenumber,
		&i.Email,
	)
	return i, err
}

const createSymptom = `-- name: CreateSymptom :one

INSERT INTO symptoms (
    symptom_name, symptom_description
) VALUES (
    $1, $2
)
RETURNING symptom_id, symptom_name, symptom_description, created_at, updated_at
`

type CreateSymptomParams struct {
	SymptomName        string
	SymptomDescription pgtype.Text
}

// === Symptom Queries ===
func (q *Queries) CreateSymptom(ctx context.Context, arg CreateSymptomParams) (Symptom, error) {
	row := q.db.QueryRow(ctx, createSymptom, arg.SymptomName, arg.SymptomDescription)
	var i Symptom
	err := row.Scan(
		&i.SymptomID,
		&i.SymptomName,
		&i.SymptomDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteDisease = `-- name: DeleteDisease :exec
DELETE FROM disease
WHERE disease_id = $1
`

// Note: ON DELETE CASCADE will handle related records in junction tables
func (q *Queries) DeleteDisease(ctx context.Context, diseaseID int32) error {
	_, err := q.db.Exec(ctx, deleteDisease, diseaseID)
	return err
}

const deletePatient = `-- name: DeletePatient :exec
DELETE FROM patient
WHERE patient_id = $1
`

// Note: ON DELETE CASCADE will handle related records in junction tables
func (q *Queries) DeletePatient(ctx context.Context, patientID int32) error {
	_, err := q.db.Exec(ctx, deletePatient, patientID)
	return err
}

const deletePatientDiseaseInstance = `-- name: DeletePatientDiseaseInstance :exec
DELETE FROM patient_disease
WHERE patient_disease_id = $1
`

// Deletes a specific diagnosis instance by its ID
// Note: ON DELETE CASCADE handles related patient_disease_symptom records
func (q *Queries) DeletePatientDiseaseInstance(ctx context.Context, patientDiseaseID int32) error {
	_, err := q.db.Exec(ctx, deletePatientDiseaseInstance, patientDiseaseID)
	return err
}

const deleteSymptom = `-- name: DeleteSymptom :exec
DELETE FROM symptoms
WHERE symptom_id = $1
`

// Note: ON DELETE CASCADE will handle related records in junction tables
func (q *Queries) DeleteSymptom(ctx context.Context, symptomID int32) error {
	_, err := q.db.Exec(ctx, deleteSymptom, symptomID)
	return err
}

const getDiseaseByCode = `-- name: GetDiseaseByCode :one
SELECT disease_id, disease_name, disease_code, disease_description, disease_treatment, created_at, updated_at FROM disease
WHERE disease_code = $1 LIMIT 1
`

func (q *Queries) GetDiseaseByCode(ctx context.Context, diseaseCode string) (Disease, error) {
	row := q.db.QueryRow(ctx, getDiseaseByCode, diseaseCode)
	var i Disease
	err := row.Scan(
		&i.DiseaseID,
		&i.DiseaseName,
		&i.DiseaseCode,
		&i.DiseaseDescription,
		&i.DiseaseTreatment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDiseaseByID = `-- name: GetDiseaseByID :one
SELECT disease_id, disease_name, disease_code, disease_description, disease_treatment, created_at, updated_at FROM disease
WHERE disease_id = $1 LIMIT 1
`

func (q *Queries) GetDiseaseByID(ctx context.Context, diseaseID int32) (Disease, error) {
	row := q.db.QueryRow(ctx, getDiseaseByID, diseaseID)
	var i Disease
	err := row.Scan(
		&i.DiseaseID,
		&i.DiseaseName,
		&i.DiseaseCode,
		&i.DiseaseDescription,
		&i.DiseaseTreatment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPatientByEmail = `-- name: GetPatientByEmail :one
SELECT patient_id, firstname, lastname, register, age, gender, birthdate, address, phonenumber, email FROM patient
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetPatientByEmail(ctx context.Context, email string) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatientByEmail, email)
	var i Patient
	err := row.Scan(
		&i.PatientID,
		&i.Firstname,
		&i.Lastname,
		&i.Register,
		&i.Age,
		&i.Gender,
		&i.Birthdate,
		&i.Address,
		&i.Phonenumber,
		&i.Email,
	)
	return i, err
}

const getPatientByID = `-- name: GetPatientByID :one
SELECT patient_id, firstname, lastname, register, age, gender, birthdate, address, phonenumber, email FROM patient
WHERE patient_id = $1 LIMIT 1
`

func (q *Queries) GetPatientByID(ctx context.Context, patientID int32) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatientByID, patientID)
	var i Patient
	err := row.Scan(
		&i.PatientID,
		&i.Firstname,
		&i.Lastname,
		&i.Register,
		&i.Age,
		&i.Gender,
		&i.Birthdate,
		&i.Address,
		&i.Phonenumber,
		&i.Email,
	)
	return i, err
}

const getPatientDiseaseHistoryWithSymptoms = `-- name: GetPatientDiseaseHistoryWithSymptoms :many

SELECT
    pt.patient_id,
    pt.firstname,
    pt.lastname,
    pd.patient_disease_id,
    d.disease_id,
    d.disease_name,
    pd.diagnosis_date,
    pd.notes AS disease_notes,
    s.symptom_id,
    s.symptom_name
FROM patient pt
JOIN patient_disease pd ON pt.patient_id = pd.patient_id
JOIN disease d ON pd.disease_id = d.disease_id
LEFT JOIN patient_disease_symptom pds ON pd.patient_disease_id = pds.patient_disease_id
LEFT JOIN symptoms s ON pds.symptom_id = s.symptom_id
WHERE pt.patient_id = $1
ORDER BY pd.diagnosis_date DESC, d.disease_name, s.symptom_name
`

type GetPatientDiseaseHistoryWithSymptomsRow struct {
	PatientID        int32
	Firstname        string
	Lastname         string
	PatientDiseaseID int32
	DiseaseID        int32
	DiseaseName      string
	DiagnosisDate    pgtype.Date
	DiseaseNotes     pgtype.Text
	SymptomID        pgtype.Int4
	SymptomName      pgtype.Text
}

// === Combined / Aggregate Queries ===
// Get all disease instances and their linked symptoms for a specific patient
func (q *Queries) GetPatientDiseaseHistoryWithSymptoms(ctx context.Context, patientID int32) ([]GetPatientDiseaseHistoryWithSymptomsRow, error) {
	rows, err := q.db.Query(ctx, getPatientDiseaseHistoryWithSymptoms, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPatientDiseaseHistoryWithSymptomsRow
	for rows.Next() {
		var i GetPatientDiseaseHistoryWithSymptomsRow
		if err := rows.Scan(
			&i.PatientID,
			&i.Firstname,
			&i.Lastname,
			&i.PatientDiseaseID,
			&i.DiseaseID,
			&i.DiseaseName,
			&i.DiagnosisDate,
			&i.DiseaseNotes,
			&i.SymptomID,
			&i.SymptomName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatientDiseaseInstanceByID = `-- name: GetPatientDiseaseInstanceByID :one

SELECT patient_disease_id, patient_id, disease_id, diagnosis_date, notes, created_at, updated_at FROM patient_disease
WHERE patient_disease_id = $1
`

// Returns the newly created patient_disease record including patient_disease_id
// Gets a specific diagnosis instance by its unique ID
func (q *Queries) GetPatientDiseaseInstanceByID(ctx context.Context, patientDiseaseID int32) (PatientDisease, error) {
	row := q.db.QueryRow(ctx, getPatientDiseaseInstanceByID, patientDiseaseID)
	var i PatientDisease
	err := row.Scan(
		&i.PatientDiseaseID,
		&i.PatientID,
		&i.DiseaseID,
		&i.DiagnosisDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPatientSummary = `-- name: GetPatientSummary :one
SELECT
    p.patient_id,
    p.firstname,
    p.lastname,
    p.email,
    -- Aggregate general symptoms from patient_symptoms
    (SELECT STRING_AGG(s_gen.symptom_name, ', ' ORDER BY s_gen.symptom_name)
     FROM symptoms s_gen
     JOIN patient_symptoms ps_gen ON s_gen.symptom_id = ps_gen.symptom_id
     WHERE ps_gen.patient_id = p.patient_id) AS general_symptoms_list,
    -- Aggregate distinct diseases from patient_disease
    (SELECT STRING_AGG(DISTINCT d_dis.disease_name, ', ' ORDER BY d_dis.disease_name)
     FROM disease d_dis
     JOIN patient_disease pd_dis ON d_dis.disease_id = pd_dis.disease_id
     WHERE pd_dis.patient_id = p.patient_id) AS distinct_diseases_list
FROM
    patient p
WHERE
    p.patient_id = $1
GROUP BY
    p.patient_id, p.firstname, p.lastname, p.email
`

type GetPatientSummaryRow struct {
	PatientID            int32
	Firstname            string
	Lastname             string
	Email                string
	GeneralSymptomsList  []byte
	DistinctDiseasesList []byte
}

// Provides a summary overview for a single patient, aggregating general symptoms and distinct diseases.
// Note: This uses the *optional* patient_symptoms table for the general symptom list.
// Note: Disease list shows unique diseases ever recorded, not specific instances.
func (q *Queries) GetPatientSummary(ctx context.Context, patientID int32) (GetPatientSummaryRow, error) {
	row := q.db.QueryRow(ctx, getPatientSummary, patientID)
	var i GetPatientSummaryRow
	err := row.Scan(
		&i.PatientID,
		&i.Firstname,
		&i.Lastname,
		&i.Email,
		&i.GeneralSymptomsList,
		&i.DistinctDiseasesList,
	)
	return i, err
}

const getSymptomByID = `-- name: GetSymptomByID :one
SELECT symptom_id, symptom_name, symptom_description, created_at, updated_at FROM symptoms
WHERE symptom_id = $1 LIMIT 1
`

func (q *Queries) GetSymptomByID(ctx context.Context, symptomID int32) (Symptom, error) {
	row := q.db.QueryRow(ctx, getSymptomByID, symptomID)
	var i Symptom
	err := row.Scan(
		&i.SymptomID,
		&i.SymptomName,
		&i.SymptomDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSymptomsForPatientDiseaseInstance = `-- name: GetSymptomsForPatientDiseaseInstance :many
SELECT
    s.symptom_id,
    s.symptom_name,
    s.symptom_description
FROM symptoms s
JOIN patient_disease_symptom pds ON s.symptom_id = pds.symptom_id
WHERE pds.patient_disease_id = $1
ORDER BY s.symptom_name
`

type GetSymptomsForPatientDiseaseInstanceRow struct {
	SymptomID          int32
	SymptomName        string
	SymptomDescription pgtype.Text
}

// Gets symptoms linked to a specific disease instance by patient_disease_id
func (q *Queries) GetSymptomsForPatientDiseaseInstance(ctx context.Context, patientDiseaseID int32) ([]GetSymptomsForPatientDiseaseInstanceRow, error) {
	rows, err := q.db.Query(ctx, getSymptomsForPatientDiseaseInstance, patientDiseaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSymptomsForPatientDiseaseInstanceRow
	for rows.Next() {
		var i GetSymptomsForPatientDiseaseInstanceRow
		if err := rows.Scan(&i.SymptomID, &i.SymptomName, &i.SymptomDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkSymptomToPatientDisease = `-- name: LinkSymptomToPatientDisease :one

INSERT INTO patient_disease_symptom (
    patient_disease_id, symptom_id
) VALUES (
    $1, $2
)
RETURNING id, patient_disease_id, symptom_id, created_at, updated_at
`

type LinkSymptomToPatientDiseaseParams struct {
	PatientDiseaseID int32
	SymptomID        int32
}

// === Patient Disease Symptom Link Queries ===
// Links a symptom to a specific patient disease instance
func (q *Queries) LinkSymptomToPatientDisease(ctx context.Context, arg LinkSymptomToPatientDiseaseParams) (PatientDiseaseSymptom, error) {
	row := q.db.QueryRow(ctx, linkSymptomToPatientDisease, arg.PatientDiseaseID, arg.SymptomID)
	var i PatientDiseaseSymptom
	err := row.Scan(
		&i.ID,
		&i.PatientDiseaseID,
		&i.SymptomID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDiseaseInstancesForPatient = `-- name: ListDiseaseInstancesForPatient :many
SELECT
    pd.patient_disease_id,
    pd.diagnosis_date,
    pd.notes,
    pd.created_at,
    pd.updated_at,
    d.disease_id,
    d.disease_name,
    d.disease_code
FROM patient_disease pd
JOIN disease d ON pd.disease_id = d.disease_id
WHERE pd.patient_id = $1
ORDER BY pd.diagnosis_date DESC, d.disease_name
`

type ListDiseaseInstancesForPatientRow struct {
	PatientDiseaseID int32
	DiagnosisDate    pgtype.Date
	Notes            pgtype.Text
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	DiseaseID        int32
	DiseaseName      string
	DiseaseCode      string
}

// Lists all recorded disease instances for a specific patient
func (q *Queries) ListDiseaseInstancesForPatient(ctx context.Context, patientID int32) ([]ListDiseaseInstancesForPatientRow, error) {
	rows, err := q.db.Query(ctx, listDiseaseInstancesForPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDiseaseInstancesForPatientRow
	for rows.Next() {
		var i ListDiseaseInstancesForPatientRow
		if err := rows.Scan(
			&i.PatientDiseaseID,
			&i.DiagnosisDate,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DiseaseID,
			&i.DiseaseName,
			&i.DiseaseCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDiseases = `-- name: ListDiseases :many
SELECT disease_id, disease_name, disease_code, disease_description, disease_treatment, created_at, updated_at FROM disease
ORDER BY disease_name
`

func (q *Queries) ListDiseases(ctx context.Context) ([]Disease, error) {
	rows, err := q.db.Query(ctx, listDiseases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Disease
	for rows.Next() {
		var i Disease
		if err := rows.Scan(
			&i.DiseaseID,
			&i.DiseaseName,
			&i.DiseaseCode,
			&i.DiseaseDescription,
			&i.DiseaseTreatment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGeneralSymptomsForPatient = `-- name: ListGeneralSymptomsForPatient :many
SELECT s.symptom_id, s.symptom_name, s.symptom_description, s.created_at, s.updated_at, ps.reported_date
FROM symptoms s
JOIN patient_symptoms ps ON s.symptom_id = ps.symptom_id
WHERE ps.patient_id = $1
ORDER BY ps.reported_date DESC, s.symptom_name
`

type ListGeneralSymptomsForPatientRow struct {
	SymptomID          int32
	SymptomName        string
	SymptomDescription pgtype.Text
	CreatedAt          pgtype.Timestamp
	UpdatedAt          pgtype.Timestamp
	ReportedDate       pgtype.Date
}

// Lists general symptoms recorded for a patient via patient_symptoms table
func (q *Queries) ListGeneralSymptomsForPatient(ctx context.Context, patientID int32) ([]ListGeneralSymptomsForPatientRow, error) {
	rows, err := q.db.Query(ctx, listGeneralSymptomsForPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGeneralSymptomsForPatientRow
	for rows.Next() {
		var i ListGeneralSymptomsForPatientRow
		if err := rows.Scan(
			&i.SymptomID,
			&i.SymptomName,
			&i.SymptomDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReportedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatientSummaries = `-- name: ListPatientSummaries :many
SELECT
    p.patient_id,
    p.firstname,
    p.lastname,
    p.email,
    (SELECT STRING_AGG(s_gen.symptom_name, ', ' ORDER BY s_gen.symptom_name)
     FROM symptoms s_gen
     JOIN patient_symptoms ps_gen ON s_gen.symptom_id = ps_gen.symptom_id
     WHERE ps_gen.patient_id = p.patient_id) AS general_symptoms_list,
    (SELECT STRING_AGG(DISTINCT d_dis.disease_name, ', ' ORDER BY d_dis.disease_name)
     FROM disease d_dis
     JOIN patient_disease pd_dis ON d_dis.disease_id = pd_dis.disease_id
     WHERE pd_dis.patient_id = p.patient_id) AS distinct_diseases_list
FROM
    patient p
GROUP BY
    p.patient_id, p.firstname, p.lastname, p.email
ORDER BY
    p.lastname, p.firstname
`

type ListPatientSummariesRow struct {
	PatientID            int32
	Firstname            string
	Lastname             string
	Email                string
	GeneralSymptomsList  []byte
	DistinctDiseasesList []byte
}

// Provides a summary overview for all patients.
// Similar aggregation logic as GetPatientSummary.
func (q *Queries) ListPatientSummaries(ctx context.Context) ([]ListPatientSummariesRow, error) {
	rows, err := q.db.Query(ctx, listPatientSummaries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPatientSummariesRow
	for rows.Next() {
		var i ListPatientSummariesRow
		if err := rows.Scan(
			&i.PatientID,
			&i.Firstname,
			&i.Lastname,
			&i.Email,
			&i.GeneralSymptomsList,
			&i.DistinctDiseasesList,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatients = `-- name: ListPatients :many
SELECT patient_id, firstname, lastname, register, age, gender, birthdate, address, phonenumber, email FROM patient
ORDER BY lastname, firstname
LIMIT $1 OFFSET $2
`

type ListPatientsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListPatients(ctx context.Context, arg ListPatientsParams) ([]Patient, error) {
	rows, err := q.db.Query(ctx, listPatients, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Patient
	for rows.Next() {
		var i Patient
		if err := rows.Scan(
			&i.PatientID,
			&i.Firstname,
			&i.Lastname,
			&i.Register,
			&i.Age,
			&i.Gender,
			&i.Birthdate,
			&i.Address,
			&i.Phonenumber,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatientsWithDiseaseInstance = `-- name: ListPatientsWithDiseaseInstance :many
SELECT p.patient_id, p.firstname, p.lastname, p.register, p.age, p.gender, p.birthdate, p.address, p.phonenumber, p.email
FROM patient p
JOIN patient_disease pd ON p.patient_id = pd.patient_id
WHERE pd.disease_id = $1
ORDER BY p.lastname, p.firstname
`

// Lists patients who have a recorded instance of a specific disease
func (q *Queries) ListPatientsWithDiseaseInstance(ctx context.Context, diseaseID int32) ([]Patient, error) {
	rows, err := q.db.Query(ctx, listPatientsWithDiseaseInstance, diseaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Patient
	for rows.Next() {
		var i Patient
		if err := rows.Scan(
			&i.PatientID,
			&i.Firstname,
			&i.Lastname,
			&i.Register,
			&i.Age,
			&i.Gender,
			&i.Birthdate,
			&i.Address,
			&i.Phonenumber,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPatientsWithGeneralSymptom = `-- name: ListPatientsWithGeneralSymptom :many
SELECT p.patient_id, p.firstname, p.lastname, p.register, p.age, p.gender, p.birthdate, p.address, p.phonenumber, p.email
FROM patient p
JOIN patient_symptoms ps ON p.patient_id = ps.patient_id
WHERE ps.symptom_id = $1
ORDER BY p.lastname, p.firstname
`

// Lists patients who reported a specific general symptom via patient_symptoms table
func (q *Queries) ListPatientsWithGeneralSymptom(ctx context.Context, symptomID int32) ([]Patient, error) {
	rows, err := q.db.Query(ctx, listPatientsWithGeneralSymptom, symptomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Patient
	for rows.Next() {
		var i Patient
		if err := rows.Scan(
			&i.PatientID,
			&i.Firstname,
			&i.Lastname,
			&i.Register,
			&i.Age,
			&i.Gender,
			&i.Birthdate,
			&i.Address,
			&i.Phonenumber,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSymptoms = `-- name: ListSymptoms :many
SELECT symptom_id, symptom_name, symptom_description, created_at, updated_at FROM symptoms
ORDER BY symptom_name
`

func (q *Queries) ListSymptoms(ctx context.Context) ([]Symptom, error) {
	rows, err := q.db.Query(ctx, listSymptoms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Symptom
	for rows.Next() {
		var i Symptom
		if err := rows.Scan(
			&i.SymptomID,
			&i.SymptomName,
			&i.SymptomDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordPatientDiseaseInstance = `-- name: RecordPatientDiseaseInstance :one

INSERT INTO patient_disease (
    patient_id, disease_id, diagnosis_date, notes
) VALUES (
    $1, $2, $3, $4
)
RETURNING patient_disease_id, patient_id, disease_id, diagnosis_date, notes, created_at, updated_at
`

type RecordPatientDiseaseInstanceParams struct {
	PatientID     int32
	DiseaseID     int32
	DiagnosisDate pgtype.Date
	Notes         pgtype.Text
}

// === Patient Disease Instance Queries ===
// Records a specific diagnosis instance for a patient
func (q *Queries) RecordPatientDiseaseInstance(ctx context.Context, arg RecordPatientDiseaseInstanceParams) (PatientDisease, error) {
	row := q.db.QueryRow(ctx, recordPatientDiseaseInstance,
		arg.PatientID,
		arg.DiseaseID,
		arg.DiagnosisDate,
		arg.Notes,
	)
	var i PatientDisease
	err := row.Scan(
		&i.PatientDiseaseID,
		&i.PatientID,
		&i.DiseaseID,
		&i.DiagnosisDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const recordPatientSymptom = `-- name: RecordPatientSymptom :one

INSERT INTO patient_symptoms (
    patient_id, symptom_id, reported_date
) VALUES (
    $1, $2, $3
)
RETURNING id, patient_id, symptom_id, reported_date, created_at, updated_at
`

type RecordPatientSymptomParams struct {
	PatientID    int32
	SymptomID    int32
	ReportedDate pgtype.Date
}

// === Patient Symptom Queries (General - Optional Table) ===
// Use these if you need to record symptoms reported outside a specific diagnosis
// Records a general symptom for a patient, optionally with a date
func (q *Queries) RecordPatientSymptom(ctx context.Context, arg RecordPatientSymptomParams) (PatientSymptom, error) {
	row := q.db.QueryRow(ctx, recordPatientSymptom, arg.PatientID, arg.SymptomID, arg.ReportedDate)
	var i PatientSymptom
	err := row.Scan(
		&i.ID,
		&i.PatientID,
		&i.SymptomID,
		&i.ReportedDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const removePatientSymptom = `-- name: RemovePatientSymptom :exec
DELETE FROM patient_symptoms
WHERE patient_id = $1 AND symptom_id = $2 AND reported_date = $3
`

type RemovePatientSymptomParams struct {
	PatientID    int32
	SymptomID    int32
	ReportedDate pgtype.Date
}

// Removes a specific general symptom record for a patient
func (q *Queries) RemovePatientSymptom(ctx context.Context, arg RemovePatientSymptomParams) error {
	_, err := q.db.Exec(ctx, removePatientSymptom, arg.PatientID, arg.SymptomID, arg.ReportedDate)
	return err
}

const removePatientSymptomByID = `-- name: RemovePatientSymptomByID :exec

DELETE FROM patient_symptoms
WHERE id = $1
`

// More specific deletion
// Removes a specific general symptom record by its ID
func (q *Queries) RemovePatientSymptomByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, removePatientSymptomByID, id)
	return err
}

const unlinkSymptomFromPatientDisease = `-- name: UnlinkSymptomFromPatientDisease :exec
DELETE FROM patient_disease_symptom
WHERE patient_disease_id = $1 AND symptom_id = $2
`

type UnlinkSymptomFromPatientDiseaseParams struct {
	PatientDiseaseID int32
	SymptomID        int32
}

// Removes the link between a symptom and a specific patient disease instance
func (q *Queries) UnlinkSymptomFromPatientDisease(ctx context.Context, arg UnlinkSymptomFromPatientDiseaseParams) error {
	_, err := q.db.Exec(ctx, unlinkSymptomFromPatientDisease, arg.PatientDiseaseID, arg.SymptomID)
	return err
}

const updateDisease = `-- name: UpdateDisease :one
UPDATE disease
SET
    disease_name = $2,
    disease_code = $3,
    disease_description = $4,
    disease_treatment = $5 -- $5 should be valid JSON(B) text or compatible type
WHERE disease_id = $1
RETURNING disease_id, disease_name, disease_code, disease_description, disease_treatment, created_at, updated_at
`

type UpdateDiseaseParams struct {
	DiseaseID          int32
	DiseaseName        string
	DiseaseCode        string
	DiseaseDescription pgtype.Text
	DiseaseTreatment   []byte
}

// updated_at is handled by trigger_set_timestamp
func (q *Queries) UpdateDisease(ctx context.Context, arg UpdateDiseaseParams) (Disease, error) {
	row := q.db.QueryRow(ctx, updateDisease,
		arg.DiseaseID,
		arg.DiseaseName,
		arg.DiseaseCode,
		arg.DiseaseDescription,
		arg.DiseaseTreatment,
	)
	var i Disease
	err := row.Scan(
		&i.DiseaseID,
		&i.DiseaseName,
		&i.DiseaseCode,
		&i.DiseaseDescription,
		&i.DiseaseTreatment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePatientAddress = `-- name: UpdatePatientAddress :one
UPDATE patient
SET
    address = $2
WHERE patient_id = $1
RETURNING patient_id, firstname, lastname, register, age, gender, birthdate, address, phonenumber, email
`

type UpdatePatientAddressParams struct {
	PatientID int32
	Address   pgtype.Text
}

// Note: patient table in the schema provided doesn't have created_at/updated_at or triggers
func (q *Queries) UpdatePatientAddress(ctx context.Context, arg UpdatePatientAddressParams) (Patient, error) {
	row := q.db.QueryRow(ctx, updatePatientAddress, arg.PatientID, arg.Address)
	var i Patient
	err := row.Scan(
		&i.PatientID,
		&i.Firstname,
		&i.Lastname,
		&i.Register,
		&i.Age,
		&i.Gender,
		&i.Birthdate,
		&i.Address,
		&i.Phonenumber,
		&i.Email,
	)
	return i, err
}

const updatePatientDetails = `-- name: UpdatePatientDetails :one

UPDATE patient
SET
    firstname = $2,
    lastname = $3,
    register = $4,
    age = $5,
    gender = $6,
    birthdate = $7,
    address = $8,
    phonenumber = $9,
    email = $10
WHERE patient_id = $1
RETURNING patient_id, firstname, lastname, register, age, gender, birthdate, address, phonenumber, email
`

type UpdatePatientDetailsParams struct {
	PatientID   int32
	Firstname   string
	Lastname    string
	Register    string
	Age         int32
	Gender      string
	Birthdate   pgtype.Date
	Address     pgtype.Text
	Phonenumber string
	Email       string
}

// For pagination
// Note: patient table in the schema provided doesn't have created_at/updated_at or triggers
func (q *Queries) UpdatePatientDetails(ctx context.Context, arg UpdatePatientDetailsParams) (Patient, error) {
	row := q.db.QueryRow(ctx, updatePatientDetails,
		arg.PatientID,
		arg.Firstname,
		arg.Lastname,
		arg.Register,
		arg.Age,
		arg.Gender,
		arg.Birthdate,
		arg.Address,
		arg.Phonenumber,
		arg.Email,
	)
	var i Patient
	err := row.Scan(
		&i.PatientID,
		&i.Firstname,
		&i.Lastname,
		&i.Register,
		&i.Age,
		&i.Gender,
		&i.Birthdate,
		&i.Address,
		&i.Phonenumber,
		&i.Email,
	)
	return i, err
}

const updatePatientDiseaseInstance = `-- name: UpdatePatientDiseaseInstance :one
UPDATE patient_disease
SET
    patient_id = $2,
    disease_id = $3,
    diagnosis_date = $4,
    notes = $5
WHERE patient_disease_id = $1
RETURNING patient_disease_id, patient_id, disease_id, diagnosis_date, notes, created_at, updated_at
`

type UpdatePatientDiseaseInstanceParams struct {
	PatientDiseaseID int32
	PatientID        int32
	DiseaseID        int32
	DiagnosisDate    pgtype.Date
	Notes            pgtype.Text
}

// Updates details of a specific diagnosis instance
// updated_at is handled by trigger_set_timestamp
func (q *Queries) UpdatePatientDiseaseInstance(ctx context.Context, arg UpdatePatientDiseaseInstanceParams) (PatientDisease, error) {
	row := q.db.QueryRow(ctx, updatePatientDiseaseInstance,
		arg.PatientDiseaseID,
		arg.PatientID,
		arg.DiseaseID,
		arg.DiagnosisDate,
		arg.Notes,
	)
	var i PatientDisease
	err := row.Scan(
		&i.PatientDiseaseID,
		&i.PatientID,
		&i.DiseaseID,
		&i.DiagnosisDate,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSymptom = `-- name: UpdateSymptom :one
UPDATE symptoms
SET
    symptom_name = $2,
    symptom_description = $3
WHERE symptom_id = $1
RETURNING symptom_id, symptom_name, symptom_description, created_at, updated_at
`

type UpdateSymptomParams struct {
	SymptomID          int32
	SymptomName        string
	SymptomDescription pgtype.Text
}

// updated_at is handled by trigger_set_timestamp
func (q *Queries) UpdateSymptom(ctx context.Context, arg UpdateSymptomParams) (Symptom, error) {
	row := q.db.QueryRow(ctx, updateSymptom, arg.SymptomID, arg.SymptomName, arg.SymptomDescription)
	var i Symptom
	err := row.Scan(
		&i.SymptomID,
		&i.SymptomName,
		&i.SymptomDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
